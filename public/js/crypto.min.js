/*!
 * timon.js
 * Copyright(c) 2024 Timon Fiedler
 * MIT Licensed
 */
class Crypto{async generateRSAKeyPair(){try{const keys=await window.crypto.subtle.generateKey({name:"RSA-OAEP",modulusLength:4096,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},true,["encrypt","decrypt"]);const publicKey=await window.crypto.subtle.exportKey("jwk",keys.publicKey);const privateKey=await window.crypto.subtle.exportKey("jwk",keys.privateKey);return{publicKey:publicKey,privateKey:privateKey}}catch(error){console.error("Error generating RSA key pair:",error);return null}}arrayBufferToBase64(buffer){const bytes=new Uint8Array(buffer);let binary="";for(let i=0;i<bytes.byteLength;i++){binary+=String.fromCharCode(bytes[i])}return btoa(binary)}base64ToArrayBuffer(base64){const binaryString=atob(base64);const len=binaryString.length;const bytes=new Uint8Array(len);for(let i=0;i<len;i++){bytes[i]=binaryString.charCodeAt(i)}return bytes.buffer}async clientEncrypt(input){const publicKeyObject=JSON.parse(window.sessionStorage.getItem("server_publicKey"));const encoder=new TextEncoder;const data=encoder.encode(input);const publicKey=await window.crypto.subtle.importKey("jwk",publicKeyObject,{name:"RSA-OAEP",hash:"SHA-256"},true,["encrypt"]);const encryptedData=await window.crypto.subtle.encrypt({name:"RSA-OAEP",hash:{name:"SHA-256"}},publicKey,data);return Array.from(new Uint8Array(encryptedData))}async encrypt(input,rawPublicKey){const encoder=new TextEncoder;const data=encoder.encode(input);const publicKey=await window.crypto.subtle.importKey("jwk",rawPublicKey,{name:"RSA-OAEP",hash:"SHA-256"},true,["encrypt"]);const encryptedData=await window.crypto.subtle.encrypt({name:"RSA-OAEP",hash:{name:"SHA-256"}},publicKey,data);return Array.from(new Uint8Array(encryptedData))}async clientDecrypt(encryptedData){const privateKeyObject=JSON.parse(window.sessionStorage.getItem("client_privateKey"));const decoder=new TextDecoder;const data=new Uint8Array(encryptedData);const privateKey=await window.crypto.subtle.importKey("jwk",privateKeyObject,{name:"RSA-OAEP",hash:"SHA-256"},true,["decrypt"]);const decryptedData=await window.crypto.subtle.decrypt({name:"RSA-OAEP",hash:{name:"SHA-256"}},privateKey,data);const decryptedInput=decoder.decode(decryptedData);return decryptedInput}async decrypt(encryptedData,rawPrivateKey){const decoder=new TextDecoder;const data=new Uint8Array(encryptedData);const privateKey=await window.crypto.subtle.importKey("jwk",rawPrivateKey,{name:"RSA-OAEP",hash:"SHA-256"},true,["decrypt"]);const decryptedData=await window.crypto.subtle.decrypt({name:"RSA-OAEP",hash:{name:"SHA-256"}},privateKey,data);const decryptedInput=decoder.decode(decryptedData);return decryptedInput}async cipherDecrypt(encrypted,rawKey,iv){const decoder=new TextDecoder;const keyBuffer=this.base64ToArrayBuffer(rawKey);const ivBuffer=this.base64ToArrayBuffer(iv);const messageBuffer=this.base64ToArrayBuffer(encrypted);const key=await crypto.subtle.importKey("raw",keyBuffer,"AES-CBC",false,["decrypt"]);const decryptedData=await window.crypto.subtle.decrypt({name:"AES-CBC",iv:ivBuffer},key,messageBuffer);const decryptedInput=decoder.decode(decryptedData);return decryptedInput}async encryptLongText(text){const iv=window.crypto.getRandomValues(new Uint8Array(16));const key=await window.crypto.subtle.generateKey({name:"AES-CBC",length:256},true,["encrypt","decrypt"]);const encoder=new TextEncoder;const encodedMessage=encoder.encode(text);const encryptedText=await window.crypto.subtle.encrypt({name:"AES-CBC",iv:iv},key,encodedMessage);const exportedKey=new Uint8Array(await window.crypto.subtle.exportKey("raw",key));const encryptedIv=await this.clientEncrypt(iv);const encryptedKey=await this.clientEncrypt(exportedKey);return{data:this.arrayBufferToBase64(encryptedText),key:encryptedKey,iv:encryptedIv}}async decryptLongText(text,key,iv){const decryptedKey=await this.clientDecrypt(key);const decryptedIv=await this.clientDecrypt(iv);const decryptedText=await this.cipherDecrypt(text,decryptedKey,decryptedIv);return decryptedText}async encryptBase64(base64){return await this.encryptLongText(base64)}async decryptBase64(base64,key,iv){return await this.decryptLongText(base64,key,iv)}}export default new Crypto;